<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SuperQueues Admin</title>
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.min.css" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body class="min-h-screen bg-base-200">
  <div id="app">
    <div class="navbar bg-base-100 shadow-lg">
      <div class="flex-1">
        <a class="btn btn-ghost text-xl">üê∞ SuperQueues</a>
      </div>
      <div class="flex-none gap-2">
        <div class="form-control">
          <input v-model="apiKey" type="password" placeholder="API Key" class="input input-bordered w-64" @change="saveApiKey">
        </div>
        <div class="badge" :class="connected ? 'badge-success' : 'badge-error'">
          {{ connected ? 'Connected' : 'Not Connected' }}
        </div>
      </div>
    </div>

    <div class="container mx-auto p-4">
      <div class="tabs tabs-boxed mb-4">
        <a class="tab" :class="{ 'tab-active': tab === 'queues' }" @click="tab = 'queues'">Queues</a>
        <a class="tab" :class="{ 'tab-active': tab === 'broker' }" @click="tab = 'broker'; loadBroker()">Broker</a>
        <a class="tab" :class="{ 'tab-active': tab === 'api-keys' }" @click="tab = 'api-keys'">API Keys</a>
        <a class="tab" :class="{ 'tab-active': tab === 'audit' }" @click="tab = 'audit'; loadAuditKeys()">Audit</a>
        <a class="tab" :class="{ 'tab-active': tab === 'settings' }" @click="tab = 'settings'">Settings</a>
      </div>

      <!-- Queues Tab -->
      <div v-if="tab === 'queues'" class="space-y-4">
        <div class="flex gap-2 items-center flex-wrap">
          <button class="btn btn-primary btn-sm" @click="loadMergedQueues">Refresh</button>
          <button class="btn btn-secondary btn-sm" @click="showPublishModal = true">Publish Test Message</button>
          <input v-model="newQueueName" placeholder="New queue name" class="input input-bordered input-sm w-64">
          <button class="btn btn-accent btn-sm" @click="startConsumer" :disabled="!newQueueName">Start Consumer</button>
          <label class="label cursor-pointer gap-2">
            <span class="label-text text-xs">Show broker stats</span>
            <input type="checkbox" v-model="showBrokerColumns" class="checkbox checkbox-xs">
          </label>
        </div>

        <div class="overflow-x-auto">
          <table class="table table-zebra w-full table-sm">
            <thead>
              <tr>
                <th>Queue</th>
                <th v-if="showBrokerColumns" class="text-cyan-400">Ready</th>
                <th v-if="showBrokerColumns" class="text-cyan-400">Unacked</th>
                <th v-if="showBrokerColumns" class="text-cyan-400">Consumers</th>
                <th>Jobs Total</th>
                <th>Queued</th>
                <th>Delivered</th>
                <th>Acked</th>
                <th>DLQ</th>
                <th>Last Activity</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="q in mergedQueues" :key="q.name">
                <td class="font-mono text-xs">{{ q.name }}</td>
                <td v-if="showBrokerColumns">
                  <span v-if="q.broker" class="badge badge-sm badge-outline badge-info">{{ q.broker.messagesReady }}</span>
                  <span v-else class="text-gray-500">-</span>
                </td>
                <td v-if="showBrokerColumns">
                  <span v-if="q.broker" class="badge badge-sm badge-outline badge-warning">{{ q.broker.messagesUnacked }}</span>
                  <span v-else class="text-gray-500">-</span>
                </td>
                <td v-if="showBrokerColumns">
                  <span v-if="q.broker" class="badge badge-sm badge-outline">{{ q.broker.consumers }}</span>
                  <span v-else class="text-gray-500">-</span>
                </td>
                <td>{{ q.jobs?.total || 0 }}</td>
                <td><span class="badge badge-sm badge-info">{{ q.jobs?.queued || 0 }}</span></td>
                <td><span class="badge badge-sm badge-warning">{{ q.jobs?.delivered || 0 }}</span></td>
                <td><span class="badge badge-sm badge-success">{{ q.jobs?.acked || 0 }}</span></td>
                <td><span class="badge badge-sm badge-error">{{ q.jobs?.dlq || 0 }}</span></td>
                <td class="text-xs">{{ formatDate(q.jobs?.lastActivity) }}</td>
                <td class="space-x-1">
                  <button class="btn btn-xs btn-info" @click="viewQueue(q.name)">View</button>
                  <button class="btn btn-xs btn-warning" @click="viewDlq(q.name)" v-if="q.jobs?.dlq > 0">DLQ</button>
                </td>
              </tr>
              <tr v-if="mergedQueues.length === 0">
                <td :colspan="showBrokerColumns ? 11 : 8" class="text-center text-gray-500">No queues found</td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Queue Detail Modal -->
        <div class="modal" :class="{ 'modal-open': selectedQueue }">
          <div class="modal-box max-w-4xl">
            <h3 class="font-bold text-lg">{{ selectedQueue }} - {{ viewingDlq ? 'DLQ' : 'Messages' }}</h3>
            <div class="py-4">
              <div class="flex gap-2 mb-4">
                <select v-model="messageFilter" class="select select-bordered select-sm" @change="loadQueueMessages">
                  <option value="">All Statuses</option>
                  <option value="queued">Queued</option>
                  <option value="delivered">Delivered</option>
                  <option value="acked">Acked</option>
                  <option value="dlq">DLQ</option>
                </select>
                <button class="btn btn-sm btn-primary" @click="loadQueueMessages">Refresh</button>
                <button v-if="viewingDlq && selectedJobs.length > 0" class="btn btn-sm btn-success" @click="requeueSelected">
                  Requeue Selected ({{ selectedJobs.length }})
                </button>
                <button v-if="viewingDlq" class="btn btn-sm btn-error" @click="purgeQueue">Purge DLQ</button>
              </div>
              <div class="overflow-x-auto max-h-96">
                <table class="table table-xs w-full">
                  <thead>
                    <tr>
                      <th v-if="viewingDlq"><input type="checkbox" class="checkbox checkbox-sm" @change="toggleAllJobs"></th>
                      <th>Job ID</th>
                      <th>Status</th>
                      <th>Attempts</th>
                      <th>Payload</th>
                      <th>Error</th>
                      <th>Updated</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="job in queueMessages" :key="job.jobId">
                      <td v-if="viewingDlq">
                        <input type="checkbox" class="checkbox checkbox-sm" :value="job.jobId" v-model="selectedJobs">
                      </td>
                      <td class="font-mono text-xs">{{ job.jobId.slice(0, 8) }}...</td>
                      <td><span class="badge badge-sm" :class="statusBadge(job.status)">{{ job.status }}</span></td>
                      <td>{{ job.attempts }}</td>
                      <td class="max-w-xs truncate font-mono text-xs">{{ JSON.stringify(job.payload) }}</td>
                      <td class="max-w-xs truncate text-error text-xs">{{ job.lastError }}</td>
                      <td class="text-xs">{{ formatDate(job.updatedAt) }}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="modal-action">
              <button class="btn" @click="selectedQueue = null">Close</button>
            </div>
          </div>
        </div>

        <!-- Publish Modal -->
        <div class="modal" :class="{ 'modal-open': showPublishModal }">
          <div class="modal-box">
            <h3 class="font-bold text-lg">Publish Test Message</h3>
            <div class="py-4 space-y-4">
              <div class="form-control">
                <label class="label"><span class="label-text">Queue Name</span></label>
                <input v-model="publishForm.queue" class="input input-bordered" placeholder="orders.created">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Payload (JSON)</span></label>
                <textarea v-model="publishForm.payload" class="textarea textarea-bordered h-32 font-mono" placeholder='{"key": "value"}'></textarea>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Correlation ID (optional)</span></label>
                <input v-model="publishForm.correlationId" class="input input-bordered" placeholder="correlation-123">
              </div>
            </div>
            <div class="modal-action">
              <button class="btn btn-ghost" @click="showPublishModal = false">Cancel</button>
              <button class="btn btn-primary" @click="publishMessage">Publish</button>
            </div>
          </div>
        </div>
      </div>

      <!-- API Keys Tab -->
      <div v-if="tab === 'api-keys'" class="space-y-4">
        <button class="btn btn-primary btn-sm" @click="showCreateKeyModal = true">Create API Key</button>

        <div class="overflow-x-auto">
          <table class="table table-zebra w-full">
            <thead>
              <tr>
                <th>Name</th>
                <th>Scopes</th>
                <th>Allowed Queues</th>
                <th>Enabled</th>
                <th>Last Used</th>
                <th>Created</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody>
              <tr v-for="key in apiKeys" :key="key._id">
                <td>{{ key.name }}</td>
                <td>
                  <span v-for="scope in key.scopes" :key="scope" class="badge badge-sm mr-1">{{ scope }}</span>
                </td>
                <td class="font-mono text-sm">{{ key.allowedQueues.join(', ') }}</td>
                <td>
                  <input type="checkbox" class="toggle toggle-success" :checked="key.enabled" @change="toggleKeyEnabled(key)">
                </td>
                <td>{{ key.lastUsedAt ? formatDate(key.lastUsedAt) : 'Never' }}</td>
                <td>{{ formatDate(key.createdAt) }}</td>
                <td>
                  <button class="btn btn-xs btn-error" @click="deleteKey(key)">Delete</button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Create Key Modal -->
        <div class="modal" :class="{ 'modal-open': showCreateKeyModal }">
          <div class="modal-box">
            <h3 class="font-bold text-lg">Create API Key</h3>
            <div class="py-4 space-y-4">
              <div class="form-control">
                <label class="label"><span class="label-text">Name</span></label>
                <input v-model="newKeyForm.name" class="input input-bordered" placeholder="my-service">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Scopes</span></label>
                <div class="flex gap-4">
                  <label class="cursor-pointer label">
                    <input type="checkbox" v-model="newKeyForm.scopes" value="publish" class="checkbox">
                    <span class="label-text ml-2">publish</span>
                  </label>
                  <label class="cursor-pointer label">
                    <input type="checkbox" v-model="newKeyForm.scopes" value="consume" class="checkbox">
                    <span class="label-text ml-2">consume</span>
                  </label>
                  <label class="cursor-pointer label">
                    <input type="checkbox" v-model="newKeyForm.scopes" value="admin" class="checkbox">
                    <span class="label-text ml-2">admin</span>
                  </label>
                </div>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Allowed Queues (comma-separated)</span></label>
                <input v-model="newKeyForm.allowedQueues" class="input input-bordered" placeholder="* or orders.*,payments.*">
              </div>
            </div>
            <div class="modal-action">
              <button class="btn btn-ghost" @click="showCreateKeyModal = false">Cancel</button>
              <button class="btn btn-primary" @click="createApiKey">Create</button>
            </div>
          </div>
        </div>

        <!-- Show Key Modal -->
        <div class="modal" :class="{ 'modal-open': createdKeyRaw }">
          <div class="modal-box">
            <h3 class="font-bold text-lg text-success">API Key Created!</h3>
            <div class="py-4">
              <div class="alert alert-warning mb-4">
                <span>Save this key now! It cannot be retrieved later.</span>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text">Raw Key</span></label>
                <input :value="createdKeyRaw" class="input input-bordered font-mono" readonly>
              </div>
              <button class="btn btn-sm btn-ghost mt-2" @click="copyKey">Copy to Clipboard</button>
            </div>
            <div class="modal-action">
              <button class="btn btn-primary" @click="createdKeyRaw = null; loadApiKeys()">Done</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Broker Tab -->
      <div v-if="tab === 'broker'" class="space-y-4">
        <div class="flex gap-2 items-center flex-wrap">
          <button class="btn btn-primary btn-sm" @click="loadBroker">Refresh</button>
          <div class="badge" :class="brokerConnected ? 'badge-success' : 'badge-error'">
            {{ brokerConnected ? 'Broker Connected' : 'Broker Unreachable' }}
          </div>
          <div v-if="clusterInfo?.isCluster" class="badge badge-info">
            Cluster: {{ clusterInfo.runningNodes }}/{{ clusterInfo.totalNodes }} nodes
          </div>
          <div v-if="clusterInfo?.hasPartitions" class="badge badge-error">
            ‚ö†Ô∏è Network Partition Detected
          </div>
        </div>

        <div v-if="clusterInfo?.isCluster" class="card bg-base-100 shadow-xl">
          <div class="card-body p-4">
            <h2 class="card-title text-sm">Cluster Topology</h2>
            <div class="flex flex-wrap gap-3">
              <div v-for="node in clusterInfo.nodes" :key="node.name" 
                   class="card bg-base-200 p-3 min-w-48">
                <div class="flex items-center gap-2">
                  <span class="badge badge-xs" :class="node.running ? 'badge-success' : 'badge-error'">
                    {{ node.running ? '‚óè' : '‚óã' }}
                  </span>
                  <span class="font-mono text-sm">{{ node.name.split('@')[1] || node.name }}</span>
                </div>
                <div class="text-xs text-gray-400 mt-1">
                  <span class="badge badge-xs badge-outline">{{ node.type }}</span>
                  <span v-if="node.memAlarm" class="badge badge-xs badge-error ml-1">mem alarm</span>
                  <span v-if="node.diskFreeAlarm" class="badge badge-xs badge-error ml-1">disk alarm</span>
                </div>
                <div class="text-xs text-gray-500 mt-1">
                  Mem: {{ formatBytes(node.memUsed) }} | Disk: {{ formatBytes(node.diskFree) }}
                </div>
                <div v-if="node.uptimeMs" class="text-xs text-gray-500">
                  Uptime: {{ formatUptime(node.uptimeMs) }}
                </div>
              </div>
            </div>
          </div>
        </div>

        <div v-if="brokerOverview" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body p-4">
              <h3 class="text-sm text-gray-400">Cluster</h3>
              <p class="font-mono text-lg">{{ brokerOverview.clusterName }}</p>
              <p class="text-xs text-gray-500">RabbitMQ {{ brokerOverview.rabbitmqVersion }}</p>
            </div>
          </div>
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body p-4">
              <h3 class="text-sm text-gray-400">Messages</h3>
              <div class="stats stats-vertical">
                <div class="stat p-1">
                  <div class="stat-title text-xs">Ready</div>
                  <div class="stat-value text-lg text-info">{{ brokerOverview.queueTotals.messagesReady }}</div>
                </div>
                <div class="stat p-1">
                  <div class="stat-title text-xs">Unacked</div>
                  <div class="stat-value text-lg text-warning">{{ brokerOverview.queueTotals.messagesUnacked }}</div>
                </div>
              </div>
            </div>
          </div>
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body p-4">
              <h3 class="text-sm text-gray-400">Rates (msg/s)</h3>
              <div class="stats stats-vertical">
                <div class="stat p-1">
                  <div class="stat-title text-xs">Publish</div>
                  <div class="stat-value text-lg">{{ brokerOverview.messageStats.publishRate.toFixed(1) }}</div>
                </div>
                <div class="stat p-1">
                  <div class="stat-title text-xs">Deliver</div>
                  <div class="stat-value text-lg">{{ brokerOverview.messageStats.deliverRate.toFixed(1) }}</div>
                </div>
              </div>
            </div>
          </div>
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body p-4">
              <h3 class="text-sm text-gray-400">Objects</h3>
              <div class="grid grid-cols-2 gap-2 text-center">
                <div>
                  <div class="text-2xl font-bold">{{ brokerOverview.queues }}</div>
                  <div class="text-xs text-gray-500">Queues</div>
                </div>
                <div>
                  <div class="text-2xl font-bold">{{ brokerOverview.consumers }}</div>
                  <div class="text-xs text-gray-500">Consumers</div>
                </div>
                <div>
                  <div class="text-2xl font-bold">{{ brokerOverview.connections }}</div>
                  <div class="text-xs text-gray-500">Connections</div>
                </div>
                <div>
                  <div class="text-2xl font-bold">{{ brokerOverview.channels }}</div>
                  <div class="text-xs text-gray-500">Channels</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <h2 class="card-title">Broker Queues</h2>
            <div class="flex flex-wrap gap-2 items-end">
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Queue name</span></label>
                <input v-model="brokerQueueName" class="input input-bordered input-sm w-64" placeholder="search..." @input="brokerPage = 1">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Vhost</span></label>
                <select v-model="brokerQueueVhost" class="select select-bordered select-sm w-56" @change="brokerPage = 1">
                  <option value="">All vhosts</option>
                  <option v-for="v in brokerQueueVhosts" :key="v" :value="v">{{ v }}</option>
                </select>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Min ready</span></label>
                <input v-model.number="brokerMinReady" type="number" min="0" class="input input-bordered input-sm w-28" @input="brokerPage = 1">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Min unacked</span></label>
                <input v-model.number="brokerMinUnacked" type="number" min="0" class="input input-bordered input-sm w-28" @input="brokerPage = 1">
              </div>
              <label class="label cursor-pointer gap-2">
                <span class="label-text text-xs">Hide empty</span>
                <input type="checkbox" v-model="brokerHideEmpty" class="checkbox checkbox-xs" @change="brokerPage = 1">
              </label>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Page size</span></label>
                <select v-model.number="brokerPageSize" class="select select-bordered select-sm w-32" @change="brokerPage = 1">
                  <option :value="10">10</option>
                  <option :value="25">25</option>
                  <option :value="50">50</option>
                  <option :value="100">100</option>
                </select>
              </div>
              <div class="ml-auto flex items-center gap-2">
                <div class="text-xs text-gray-400">
                  Showing {{ brokerQueuesRangeStart }}-{{ brokerQueuesRangeEnd }} of {{ brokerQueuesFilteredCount }}
                </div>
                <button class="btn btn-xs" @click="prevBrokerPage" :disabled="brokerPage <= 1">Prev</button>
                <div class="badge badge-outline">{{ brokerPage }} / {{ brokerQueuesPageCount || 1 }}</div>
                <button class="btn btn-xs" @click="nextBrokerPage" :disabled="brokerQueuesPageCount === 0 || brokerPage >= brokerQueuesPageCount">Next</button>
              </div>
            </div>
            <div class="overflow-x-auto">
              <table class="table table-zebra table-sm w-full">
                <thead>
                  <tr>
                    <th>Queue</th>
                    <th>Vhost</th>
                    <th>State</th>
                    <th>Ready</th>
                    <th>Unacked</th>
                    <th>Total</th>
                    <th>Consumers</th>
                    <th>Publish/s</th>
                    <th>Deliver/s</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="q in brokerQueuesPaged" :key="q.vhost + ':' + q.name">
                    <td class="font-mono text-xs">{{ q.name }}</td>
                    <td class="font-mono text-xs">{{ q.vhost }}</td>
                    <td>
                      <span class="badge badge-xs" :class="q.state === 'running' ? 'badge-success' : 'badge-warning'">{{ q.state }}</span>
                    </td>
                    <td><span class="badge badge-sm badge-info">{{ q.messagesReady }}</span></td>
                    <td><span class="badge badge-sm badge-warning">{{ q.messagesUnacked }}</span></td>
                    <td>{{ q.messages }}</td>
                    <td>{{ q.consumers }}</td>
                    <td>{{ q.messageStats.publishRate.toFixed(1) }}</td>
                    <td>{{ q.messageStats.deliverRate.toFixed(1) }}</td>
                  </tr>
                  <tr v-if="brokerQueuesPaged.length === 0">
                    <td colspan="9" class="text-center text-gray-500">No queues match filters</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
          <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
              <h2 class="card-title">Connections</h2>
              <div class="overflow-x-auto max-h-64">
                <table class="table table-xs w-full">
                  <thead>
                    <tr>
                      <th>User</th>
                      <th>Vhost</th>
                      <th>Channels</th>
                      <th>State</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="c in brokerConnections" :key="c.name">
                      <td>{{ c.user }}</td>
                      <td>{{ c.vhost }}</td>
                      <td>{{ c.channels }}</td>
                      <td>
                        <span class="badge badge-xs" :class="c.state === 'running' ? 'badge-success' : 'badge-warning'">{{ c.state }}</span>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <div class="card bg-base-100 shadow-xl">
            <div class="card-body">
              <h2 class="card-title">Nodes</h2>
              <div class="overflow-x-auto max-h-64">
                <table class="table table-xs w-full">
                  <thead>
                    <tr>
                      <th>Name</th>
                      <th>Memory</th>
                      <th>Disk</th>
                      <th>Running</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="n in brokerNodes" :key="n.name">
                      <td class="font-mono text-xs">{{ n.name.split('@')[1] || n.name }}</td>
                      <td>
                        <span :class="n.memAlarm ? 'text-error' : ''">{{ formatBytes(n.memUsed) }}</span>
                      </td>
                      <td>
                        <span :class="n.diskFreeAlarm ? 'text-error' : ''">{{ formatBytes(n.diskFree) }}</span>
                      </td>
                      <td>
                        <span class="badge badge-xs" :class="n.running ? 'badge-success' : 'badge-error'">{{ n.running ? 'Yes' : 'No' }}</span>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Audit Tab -->
      <div v-if="tab === 'audit'" class="space-y-4">
        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <h2 class="card-title">API Key Usage Audit</h2>
            <div class="flex flex-wrap gap-3 items-end">
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">API Key</span></label>
                <select v-model="auditKeyId" class="select select-bordered select-sm w-64" @change="loadAuditUsage">
                  <option value="">Select an API key</option>
                  <option v-for="key in auditKeys" :key="key._id" :value="key._id">{{ key.name }}</option>
                </select>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">From</span></label>
                <input type="date" v-model="auditFrom" class="input input-bordered input-sm" @change="loadAuditUsage">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">To</span></label>
                <input type="date" v-model="auditTo" class="input input-bordered input-sm" @change="loadAuditUsage">
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Action</span></label>
                <select v-model="auditAction" class="select select-bordered select-sm" @change="loadAuditUsage">
                  <option value="">All actions</option>
                  <option value="queues.publish">queues.publish</option>
                  <option value="queues.pull">queues.pull</option>
                  <option value="queues.ack">queues.ack</option>
                  <option value="queues.nack">queues.nack</option>
                  <option value="admin.listApiKeys">admin.listApiKeys</option>
                  <option value="admin.createApiKey">admin.createApiKey</option>
                  <option value="admin.listQueues">admin.listQueues</option>
                </select>
              </div>
              <div class="form-control">
                <label class="label"><span class="label-text text-xs">Status</span></label>
                <select v-model="auditStatus" class="select select-bordered select-sm" @change="loadAuditUsage">
                  <option value="">All</option>
                  <option value="success">Success</option>
                  <option value="error">Error</option>
                </select>
              </div>
              <button class="btn btn-primary btn-sm" @click="loadAuditUsage" :disabled="!auditKeyId">Refresh</button>
              <button class="btn btn-secondary btn-sm" @click="loadAuditSummary" :disabled="!auditKeyId">Summary</button>
            </div>
          </div>
        </div>

        <!-- Usage Summary -->
        <div v-if="auditSummary" class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <div class="flex justify-between items-center">
              <h2 class="card-title">Usage Summary: {{ auditSummary.apiKeyName }}</h2>
              <button class="btn btn-ghost btn-xs" @click="auditSummary = null">‚úï</button>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-3 mt-2">
              <div v-for="t in auditSummary.totals" :key="t.action" class="stat bg-base-200 rounded-lg p-3">
                <div class="stat-title text-xs truncate">{{ t.action }}</div>
                <div class="stat-value text-lg">{{ t.count }}</div>
                <div class="stat-desc text-xs">
                  <span class="text-error">{{ t.errors }} err</span> ¬∑ {{ t.avgLatencyMs }}ms avg
                </div>
              </div>
            </div>
            <div class="divider">Daily Breakdown</div>
            <div class="overflow-x-auto max-h-64">
              <table class="table table-xs w-full">
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Total</th>
                    <th>Errors</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="b in auditSummary.buckets" :key="b.bucket">
                    <td class="font-mono">{{ b.bucket }}</td>
                    <td><span class="badge badge-sm badge-info">{{ b.totalCount }}</span></td>
                    <td><span class="badge badge-sm" :class="b.totalErrors > 0 ? 'badge-error' : 'badge-ghost'">{{ b.totalErrors }}</span></td>
                    <td class="text-xs">
                      <span v-for="a in b.actions" :key="a.action" class="mr-2">
                        {{ a.action.split('.')[1] || a.action }}: {{ a.count }}
                      </span>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Usage Events -->
        <div v-if="auditKeyId" class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <h2 class="card-title">Recent Events</h2>
            <div class="overflow-x-auto">
              <table class="table table-zebra table-sm w-full">
                <thead>
                  <tr>
                    <th>Timestamp</th>
                    <th>Action</th>
                    <th>Scope</th>
                    <th>Queue</th>
                    <th>Method</th>
                    <th>Status</th>
                    <th>Latency</th>
                    <th>IP</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="e in auditEvents" :key="e._id">
                    <td class="text-xs">{{ formatDate(e.at) }}</td>
                    <td class="font-mono text-xs">{{ e.action }}</td>
                    <td><span class="badge badge-xs badge-outline">{{ e.scope }}</span></td>
                    <td class="font-mono text-xs">{{ e.queue || '-' }}</td>
                    <td class="text-xs">{{ e.http.method }}</td>
                    <td>
                      <span class="badge badge-xs" :class="e.http.statusCode < 400 ? 'badge-success' : 'badge-error'">
                        {{ e.http.statusCode }}
                      </span>
                    </td>
                    <td class="text-xs">{{ e.latencyMs }}ms</td>
                    <td class="text-xs text-gray-500">{{ e.ip }}</td>
                  </tr>
                  <tr v-if="auditEvents.length === 0">
                    <td colspan="8" class="text-center text-gray-500">No events found</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="flex justify-end mt-2" v-if="auditNextCursor">
              <button class="btn btn-sm btn-ghost" @click="loadMoreAuditEvents">Load More</button>
            </div>
          </div>
        </div>

        <div v-if="!auditKeyId" class="alert">
          <span>Select an API key to view usage audit data.</span>
        </div>
      </div>

      <!-- Settings Tab -->
      <div v-if="tab === 'settings'" class="space-y-4">
        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <h2 class="card-title">Audit Mode</h2>
            <p class="text-sm text-gray-500">Control how much job history is recorded. Reduce for high-throughput scenarios.</p>
            <div class="form-control w-full max-w-xs">
              <select v-model="settings.auditMode" class="select select-bordered" @change="updateSettings">
                <option value="full">Full (jobs + events)</option>
                <option value="jobs_only">Jobs Only (no events)</option>
                <option value="off">Off (no history)</option>
              </select>
            </div>
            <div class="mt-4">
              <div class="badge" :class="auditModeBadge">Current: {{ settings.auditMode }}</div>
            </div>
          </div>
        </div>

        <div class="card bg-base-100 shadow-xl">
          <div class="card-body">
            <h2 class="card-title">System Info</h2>
            <div class="stats shadow">
              <div class="stat">
                <div class="stat-title">Total Queues</div>
                <div class="stat-value">{{ mergedQueues.length }}</div>
              </div>
              <div class="stat">
                <div class="stat-title">Total API Keys</div>
                <div class="stat-value">{{ apiKeys.length }}</div>
              </div>
              <div class="stat">
                <div class="stat-title">Broker Queues</div>
                <div class="stat-value">{{ brokerQueues.length }}</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Toast -->
      <div class="toast toast-end" v-if="toast.show">
        <div class="alert" :class="toast.type === 'error' ? 'alert-error' : 'alert-success'">
          <span>{{ toast.message }}</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const { createApp, ref, computed, onMounted, watch } = Vue;

    createApp({
      setup() {
        const apiKey = ref(localStorage.getItem('sq_api_key') || '');
        const connected = ref(false);
        const tab = ref('queues');
        const toast = ref({ show: false, message: '', type: 'success' });

        const queues = ref([]);
        const mergedQueues = ref([]);
        const apiKeys = ref([]);
        const settings = ref({ auditMode: 'full' });
        const showBrokerColumns = ref(true);

        const brokerConnected = ref(false);
        const brokerOverview = ref(null);
        const brokerQueues = ref([]);
        const brokerConnections = ref([]);
        const brokerNodes = ref([]);
        const clusterInfo = ref(null);

        const brokerQueueName = ref('');
        const brokerQueueVhost = ref('');
        const brokerMinReady = ref(0);
        const brokerMinUnacked = ref(0);
        const brokerHideEmpty = ref(false);
        const brokerPageSize = ref(25);
        const brokerPage = ref(1);

        const brokerQueueVhosts = computed(() => {
          const vhosts = new Set((brokerQueues.value || []).map(q => q.vhost).filter(Boolean));
          return Array.from(vhosts).sort();
        });

        const brokerQueuesFiltered = computed(() => {
          const nameNeedle = (brokerQueueName.value || '').trim().toLowerCase();
          const vhostNeedle = brokerQueueVhost.value;
          const minReady = Number.isFinite(brokerMinReady.value) ? brokerMinReady.value : 0;
          const minUnacked = Number.isFinite(brokerMinUnacked.value) ? brokerMinUnacked.value : 0;
          const hideEmpty = !!brokerHideEmpty.value;

          return (brokerQueues.value || []).filter(q => {
            if (vhostNeedle && q.vhost !== vhostNeedle) return false;
            if (nameNeedle && !(q.name || '').toLowerCase().includes(nameNeedle)) return false;
            if (hideEmpty && (q.messages || 0) === 0) return false;
            if ((q.messagesReady || 0) < minReady) return false;
            if ((q.messagesUnacked || 0) < minUnacked) return false;
            return true;
          });
        });

        const brokerQueuesFilteredCount = computed(() => brokerQueuesFiltered.value.length);

        const brokerQueuesPageCount = computed(() => {
          const total = brokerQueuesFiltered.value.length;
          if (total === 0) return 0;
          return Math.ceil(total / brokerPageSize.value);
        });

        const brokerQueuesPaged = computed(() => {
          const total = brokerQueuesFiltered.value.length;
          if (total === 0) return [];
          const pageCount = brokerQueuesPageCount.value || 1;
          const page = Math.min(Math.max(1, brokerPage.value), pageCount);
          const start = (page - 1) * brokerPageSize.value;
          return brokerQueuesFiltered.value.slice(start, start + brokerPageSize.value);
        });

        const brokerQueuesRangeStart = computed(() => {
          if (brokerQueuesFiltered.value.length === 0) return 0;
          const pageCount = brokerQueuesPageCount.value || 1;
          const page = Math.min(Math.max(1, brokerPage.value), pageCount);
          return (page - 1) * brokerPageSize.value + 1;
        });

        const brokerQueuesRangeEnd = computed(() => {
          if (brokerQueuesFiltered.value.length === 0) return 0;
          return Math.min(brokerQueuesRangeStart.value + brokerQueuesPaged.value.length - 1, brokerQueuesFiltered.value.length);
        });

        const prevBrokerPage = () => {
          brokerPage.value = Math.max(1, brokerPage.value - 1);
        };

        const nextBrokerPage = () => {
          const pc = brokerQueuesPageCount.value;
          if (pc === 0) return;
          brokerPage.value = Math.min(pc, brokerPage.value + 1);
        };

        watch([
          brokerQueueName,
          brokerQueueVhost,
          brokerMinReady,
          brokerMinUnacked,
          brokerHideEmpty,
        ], () => {
          brokerPage.value = 1;
        });

        watch([brokerQueuesFiltered, brokerPageSize], () => {
          const pc = brokerQueuesPageCount.value;
          if (pc === 0) {
            brokerPage.value = 1;
            return;
          }
          if (brokerPage.value > pc) brokerPage.value = pc;
          if (brokerPage.value < 1) brokerPage.value = 1;
        });

        const selectedQueue = ref(null);
        const queueMessages = ref([]);
        const messageFilter = ref('');
        const viewingDlq = ref(false);
        const selectedJobs = ref([]);

        const showPublishModal = ref(false);
        const publishForm = ref({ queue: '', payload: '{}', correlationId: '' });

        const showCreateKeyModal = ref(false);
        const newKeyForm = ref({ name: '', scopes: ['publish', 'consume'], allowedQueues: '*' });
        const createdKeyRaw = ref(null);

        const newQueueName = ref('');

        const auditKeys = ref([]);
        const auditKeyId = ref('');
        const auditFrom = ref('');
        const auditTo = ref('');
        const auditAction = ref('');
        const auditStatus = ref('');
        const auditEvents = ref([]);
        const auditNextCursor = ref(null);
        const auditSummary = ref(null);

        const saveApiKey = () => {
          localStorage.setItem('sq_api_key', apiKey.value);
          testConnection();
        };

        const showToast = (message, type = 'success') => {
          toast.value = { show: true, message, type };
          setTimeout(() => toast.value.show = false, 3000);
        };

        const api = async (method, path, body = null) => {
          const res = await fetch(`/v1${path}`, {
            method,
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `ApiKey ${apiKey.value}`,
            },
            body: body ? JSON.stringify(body) : null,
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data.error || 'Request failed');
          return data;
        };

        const testConnection = async () => {
          try {
            await api('GET', '/admin/settings');
            connected.value = true;
            loadAll();
          } catch {
            connected.value = false;
          }
        };

        const loadAll = () => {
          loadMergedQueues();
          loadApiKeys();
          loadSettings();
        };

        const loadQueues = async () => {
          try {
            const data = await api('GET', '/admin/queues');
            queues.value = data.queues;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadMergedQueues = async () => {
          try {
            const data = await api('GET', '/admin/queues/merged');
            mergedQueues.value = data.queues;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadBroker = async () => {
          try {
            const [overview, queuesData, connections, nodes, cluster] = await Promise.all([
              api('GET', '/admin/broker/overview').catch(() => null),
              api('GET', '/admin/broker/queues').catch(() => ({ queues: [] })),
              api('GET', '/admin/broker/connections').catch(() => ({ connections: [] })),
              api('GET', '/admin/broker/nodes').catch(() => ({ nodes: [] })),
              api('GET', '/admin/broker/cluster').catch(() => null),
            ]);
            brokerOverview.value = overview;
            brokerQueues.value = queuesData.queues || [];
            brokerConnections.value = connections.connections || [];
            brokerNodes.value = nodes.nodes || [];
            clusterInfo.value = cluster;
            brokerConnected.value = !!overview;
            brokerPage.value = 1;
          } catch (e) {
            brokerConnected.value = false;
            showToast(e.message, 'error');
          }
        };

        const formatBytes = (bytes) => {
          if (!bytes) return '0 B';
          const k = 1024;
          const sizes = ['B', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        };

        const formatUptime = (ms) => {
          if (!ms) return '-';
          const seconds = Math.floor(ms / 1000);
          const minutes = Math.floor(seconds / 60);
          const hours = Math.floor(minutes / 60);
          const days = Math.floor(hours / 24);
          if (days > 0) return `${days}d ${hours % 24}h`;
          if (hours > 0) return `${hours}h ${minutes % 60}m`;
          if (minutes > 0) return `${minutes}m`;
          return `${seconds}s`;
        };

        const loadApiKeys = async () => {
          try {
            const data = await api('GET', '/admin/api-keys');
            apiKeys.value = data.keys;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadSettings = async () => {
          try {
            const data = await api('GET', '/admin/settings');
            settings.value = data;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const updateSettings = async () => {
          try {
            await api('POST', '/admin/settings', { auditMode: settings.value.auditMode });
            showToast('Settings updated');
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const viewQueue = async (name) => {
          selectedQueue.value = name;
          viewingDlq.value = false;
          messageFilter.value = '';
          selectedJobs.value = [];
          await loadQueueMessages();
        };

        const viewDlq = async (name) => {
          selectedQueue.value = name;
          viewingDlq.value = true;
          messageFilter.value = 'dlq';
          selectedJobs.value = [];
          await loadQueueMessages();
        };

        const loadQueueMessages = async () => {
          try {
            const filter = messageFilter.value ? `?status=${messageFilter.value}` : '';
            const data = await api('GET', `/admin/queues/${encodeURIComponent(selectedQueue.value)}/messages${filter}`);
            queueMessages.value = data.jobs;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const publishMessage = async () => {
          try {
            let payload;
            try {
              payload = JSON.parse(publishForm.value.payload);
            } catch {
              showToast('Invalid JSON payload', 'error');
              return;
            }
            await api('POST', `/admin/queues/${encodeURIComponent(publishForm.value.queue)}/publish`, {
              payload,
              correlationId: publishForm.value.correlationId || undefined,
            });
            showToast('Message published');
            showPublishModal.value = false;
            publishForm.value = { queue: '', payload: '{}', correlationId: '' };
            loadQueues();
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const requeueSelected = async () => {
          try {
            await api('POST', `/admin/queues/${encodeURIComponent(selectedQueue.value)}/requeue`, {
              jobIds: selectedJobs.value,
            });
            showToast(`Requeued ${selectedJobs.value.length} messages`);
            selectedJobs.value = [];
            loadQueueMessages();
            loadQueues();
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const purgeQueue = async () => {
          if (!confirm('Are you sure you want to purge the DLQ?')) return;
          try {
            const data = await api('POST', `/admin/queues/${encodeURIComponent(selectedQueue.value)}/purge`, {
              status: 'dlq',
            });
            showToast(`Purged ${data.deleted} messages`);
            loadQueueMessages();
            loadQueues();
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const startConsumer = async () => {
          try {
            await api('POST', `/admin/queues/${encodeURIComponent(newQueueName.value)}/consumer`);
            showToast(`Consumer started for ${newQueueName.value}`);
            newQueueName.value = '';
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const toggleAllJobs = (e) => {
          if (e.target.checked) {
            selectedJobs.value = queueMessages.value.map(j => j.jobId);
          } else {
            selectedJobs.value = [];
          }
        };

        const createApiKey = async () => {
          try {
            const data = await api('POST', '/admin/api-keys', {
              name: newKeyForm.value.name,
              scopes: newKeyForm.value.scopes,
              allowedQueues: newKeyForm.value.allowedQueues.split(',').map(s => s.trim()),
            });
            createdKeyRaw.value = data.rawKey;
            showCreateKeyModal.value = false;
            newKeyForm.value = { name: '', scopes: ['publish', 'consume'], allowedQueues: '*' };
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const toggleKeyEnabled = async (key) => {
          try {
            await api('PATCH', `/admin/api-keys/${key._id}`, { enabled: !key.enabled });
            loadApiKeys();
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const deleteKey = async (key) => {
          if (!confirm(`Delete API key "${key.name}"?`)) return;
          try {
            await api('DELETE', `/admin/api-keys/${key._id}`);
            showToast('API key deleted');
            loadApiKeys();
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const copyKey = () => {
          navigator.clipboard.writeText(createdKeyRaw.value);
          showToast('Copied to clipboard');
        };

        const loadAuditKeys = async () => {
          try {
            const data = await api('GET', '/admin/api-keys');
            auditKeys.value = data.keys;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadAuditUsage = async () => {
          if (!auditKeyId.value) return;
          try {
            const params = new URLSearchParams();
            if (auditFrom.value) params.append('from', auditFrom.value);
            if (auditTo.value) params.append('to', auditTo.value);
            if (auditAction.value) params.append('action', auditAction.value);
            if (auditStatus.value) params.append('status', auditStatus.value);
            params.append('limit', '50');
            const data = await api('GET', `/admin/api-keys/${auditKeyId.value}/usage?${params}`);
            auditEvents.value = data.events;
            auditNextCursor.value = data.nextCursor;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadMoreAuditEvents = async () => {
          if (!auditKeyId.value || !auditNextCursor.value) return;
          try {
            const params = new URLSearchParams();
            if (auditFrom.value) params.append('from', auditFrom.value);
            if (auditTo.value) params.append('to', auditTo.value);
            if (auditAction.value) params.append('action', auditAction.value);
            if (auditStatus.value) params.append('status', auditStatus.value);
            params.append('limit', '50');
            params.append('cursor', auditNextCursor.value);
            const data = await api('GET', `/admin/api-keys/${auditKeyId.value}/usage?${params}`);
            auditEvents.value = [...auditEvents.value, ...data.events];
            auditNextCursor.value = data.nextCursor;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const loadAuditSummary = async () => {
          if (!auditKeyId.value) return;
          try {
            const params = new URLSearchParams();
            if (auditFrom.value) params.append('from', auditFrom.value);
            if (auditTo.value) params.append('to', auditTo.value);
            const data = await api('GET', `/admin/api-keys/${auditKeyId.value}/usage/summary?${params}`);
            auditSummary.value = data;
          } catch (e) {
            showToast(e.message, 'error');
          }
        };

        const formatDate = (d) => {
          if (!d) return '-';
          return new Date(d).toLocaleString();
        };

        const statusBadge = (status) => ({
          'badge-info': status === 'queued',
          'badge-warning': status === 'delivered',
          'badge-success': status === 'acked',
          'badge-error': status === 'dlq' || status === 'failed',
        });

        const auditModeBadge = computed(() => ({
          'badge-success': settings.value.auditMode === 'full',
          'badge-warning': settings.value.auditMode === 'jobs_only',
          'badge-error': settings.value.auditMode === 'off',
        }));

        onMounted(() => {
          if (apiKey.value) testConnection();
        });

        return {
          apiKey, connected, tab, toast,
          queues, mergedQueues, apiKeys, settings, showBrokerColumns,
          brokerConnected, brokerOverview, brokerQueues, brokerConnections, brokerNodes,
          clusterInfo,
          brokerQueueName, brokerQueueVhost, brokerQueueVhosts,
          brokerMinReady, brokerMinUnacked, brokerHideEmpty,
          brokerPageSize, brokerPage,
          brokerQueuesFilteredCount, brokerQueuesPageCount, brokerQueuesPaged,
          brokerQueuesRangeStart, brokerQueuesRangeEnd,
          selectedQueue, queueMessages, messageFilter, viewingDlq, selectedJobs,
          showPublishModal, publishForm,
          showCreateKeyModal, newKeyForm, createdKeyRaw,
          newQueueName,
          saveApiKey, loadQueues, loadMergedQueues, loadBroker, loadApiKeys, updateSettings,
          prevBrokerPage, nextBrokerPage,
          viewQueue, viewDlq, loadQueueMessages,
          publishMessage, requeueSelected, purgeQueue, startConsumer, toggleAllJobs,
          createApiKey, toggleKeyEnabled, deleteKey, copyKey,
          auditKeys, auditKeyId, auditFrom, auditTo, auditAction, auditStatus,
          auditEvents, auditNextCursor, auditSummary,
          loadAuditKeys, loadAuditUsage, loadMoreAuditEvents, loadAuditSummary,
          formatDate, formatBytes, formatUptime, statusBadge, auditModeBadge,
        };
      },
    }).mount('#app');
  </script>
</body>
</html>
